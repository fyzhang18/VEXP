---
title: "VEXP_Analysis"
author: "Felicia Zhang"
date: '2018-08-24'
output: html_document
---

```{r setup, include=FALSE}
library(ggplot2) 
library(zoo)
library(reshape)
library(plyr)
library(dplyr)
library(scales) 
library(data.table)
library(signal)
library(matrixStats)
library(lme4)
library(arm)
library(RColorBrewer)
library(lmerTest)
library(boot)

# load preprocessed data
orig.sample <- read.csv("/Volumes/emberson/ResearchProjects/Pupillometry/VExP/V1/data/VEXP_1-6_Infant_Preprocessed_RemovedTrackloss.csv")
orig.sample$X <- NULL

#relabel training pupil corrected from 999 to NA
orig.sample$PUPIL_CORRECTED[orig.sample$phase==0] <- NA
```

Important information

Trial
0 = Blank (0-1200)
1 = Picture (1200-2200)

Counterbalance:
1. L=pattern, R=random, 
2. L=pattern, R=random,
3. L=random, R=pattern, 
4. L=random, R=pattern,

Imgseq:
1 & 2 = Left
3 & 4 = Right

Side:
1 = Left
2 = Right

Phase:
0 = training
1 = test

Condition:
2 = training
0 = random
1 = pattern

Percentage of test phase data we have for each subject (missing samples/total samples)
```{r}
# get test phase data
test <- subset(orig.sample, phase==1)

# calculate percent missing
v1 <- group_by(test, subID) %>%
  summarize(percentmissing = length(which(is.na(PUPIL_CORRECTED))) / length(PUPIL_CORRECTED),
            percentcompleted = 1 - percentmissing)

# plot
ggplot(v1,aes(x=factor(subID),y=percentcompleted))+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  geom_bar(stat="identity")+
  labs(x = "Subject ID", y = "% of data")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  theme(legend.position="none")+
  theme(plot.title = element_text(hjust = 0.5))+
  scale_y_continuous(labels = scales::percent,limits=c(0,1),breaks=seq(0,1,.1))+
  geom_hline(yintercept = 0.5, color="red",size=1.5)
```

Percentage of test phase data we have for each subject (good trials/total trials)
```{r}
# get test phase data
test <- subset(orig.sample, phase==1)

# calculate percent missing for each trial
trialinfo <- group_by(test, subID, TRIAL_INDEX_RECODE) %>%
  summarize(percentmissing = length(which(is.na(PUPIL_CORRECTED))) / length(PUPIL_CORRECTED),
            percentcompleted = 1 - percentmissing)

# calculate number of good trials
foo <- group_by(trialinfo, subID) %>%
  summarize(goodtrials = length(which(percentcompleted > 0.49999)),
            percenttrials = goodtrials/80)

# plot
ggplot(foo,aes(x=factor(subID),y=percenttrials))+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  geom_bar(stat="identity")+
  labs(x = "Subject ID", y = "% of good trials (# good trials/80)")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  theme(legend.position="none")+
  theme(plot.title = element_text(hjust = 0.5))+
  scale_y_continuous(labels = scales::percent,limits=c(0,1),breaks=seq(0,1,.1))+
  geom_hline(yintercept = 0.5, color="red",size=1.5)
```

REMOVE BAD SUBJECTS ( < 50% of good trials)
```{r}
# which subjects have less than 50% good trials
z <- foo$subID[which(foo$percenttrials < .50)]

# remove those subjects
orig.sample.a <- subset(orig.sample, subID != z)

unique(orig.sample.a$subID)
```

Comparing looking at target criteria (liberal vs conservative)
```{r}
# calculate percent looking for conservative
goo <- group_by(orig.sample.a, subID, TRIAL_INDEX_RECODE, trial) %>%
  summarise(
    percentlooking=length(which(lookattarget==1))/length(trial),
    type = 0
  )

# calculate percent looking for liberal
goo2 <- group_by(orig.sample.a, subID, TRIAL_INDEX_RECODE, trial) %>%
  summarise(
    percentlooking=length(which(lookattarget_lib==1))/length(trial),
    type = 1
  )

# combine
foo <- rbind(goo, goo2)

# calculate mean and SE
foo2 <- group_by(foo, trial, type) %>%
  summarise(
    meanlooking=mean(percentlooking,na.rm = TRUE),
    selooking=sd(percentlooking, na.rm = TRUE)/sqrt(length(percentlooking))
  )

# plot
limits <- aes(ymax = meanlooking + selooking, ymin=meanlooking - selooking)
dodge <- position_dodge(width=0.9)

ggplot(foo2,aes(x=factor(trial),y=meanlooking,color=factor(type),fill=factor(type)))+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  geom_bar(stat="identity",position=dodge)+
  ggtitle(" 'Looking at target' criteria comparison")+
  labs(x = "Trial", y = "Looking at target")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  theme(plot.title = element_text(hjust = 0.5))+
  scale_y_continuous(labels=percent,limits=c(0,.5),breaks=seq(0,.5,.05))+
  scale_x_discrete(breaks=c("0","1"),labels=c("ISI", "Image"))+
  geom_errorbar(limits, width=0.25,position = position_dodge(0.9),color="black")+
  guides(color=FALSE)+
  scale_fill_discrete(name="Method",breaks=c("0","1"),labels=c("Conservative", "Liberal"))

#Liberal method increases our "looking at target" percentage 
```

Compare pupil size for condition (all samples)
```{r}
# get test phase data
poo <- subset(orig.sample.a, phase==1)

# calculate mean pupil for each trial
foo <- group_by(poo, subID, TRIAL_INDEX_RECODE, trial, condition) %>%
  summarise(
    pupilsize=mean(PUPIL_CORRECTED, na.rm = TRUE)
  )

# collapse across subjects
foo2 <- group_by(foo, trial, condition) %>%
  summarise(
    meanPupil=mean(pupilsize,na.rm = TRUE),
    sePupil=sd(pupilsize, na.rm = TRUE)/sqrt(length(pupilsize))
  )

# plot
limits <- aes(ymax = meanPupil + sePupil, ymin=meanPupil - sePupil)
dodge <- position_dodge(width=0.9)

ggplot(foo2,aes(x=factor(trial),y=meanPupil,color=factor(condition),fill=factor(condition)))+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  geom_bar(stat="identity",position=dodge)+
  ggtitle("All samples")+
  labs(x = "Trial", y = "Pupil change from baseline")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  theme(plot.title = element_text(hjust = 0.5))+
  scale_y_continuous(labels=percent,limits=c(-0.3,.1),breaks=seq(-0.3,.1,.05))+
  scale_x_discrete(breaks=c("0","1"),labels=c("ISI", "Image"))+
  geom_errorbar(limits, width=0.25,position = position_dodge(0.9),color="black")+
  guides(color=FALSE)+
  theme(legend.position="bottom")+
  scale_fill_brewer(palette="Accent",name="Condition",breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  scale_color_brewer(palette="Accent")

#Recall that our baseline was measured: during training, when they're looking at a picture on the left/right side 
#Results suggest that during test phase, their pupil size when they're viewing an image didn't change much than when it was during training phase. The unpredictable condition seems to be exactly like baseline (makes sense since our baseline was unpredictable). The unpredictable condition might be a bit smaller than baseline. This aligns with our hypothesis that predictable = smaller PDR, and unpredictable/PE/surprise = bigger PDR
#What stands out the most is the ISI pupil change is extremely negative, probably due to looking around. 
```

Compare pupil size for condition (looking at target, liberal)
```{r}
# calculate mean pupil for each trial
foo <- group_by(poo, subID, TRIAL_INDEX_RECODE, trial, condition, lookattarget_lib) %>%
  summarise(
    pupilsize=mean(PUPIL_CORRECTED, na.rm = TRUE)
  )

# collapse across subjects
foo2 <- group_by(foo, trial, condition,lookattarget_lib) %>%
  summarise(
    meanPupil=mean(pupilsize,na.rm = TRUE),
    sePupil=sd(pupilsize, na.rm = TRUE)/sqrt(length(pupilsize))
  )

#only looking at target
foo2 <- subset(foo2, lookattarget_lib==1)

# plot
limits <- aes(ymax = meanPupil + sePupil, ymin=meanPupil - sePupil)
dodge <- position_dodge(width=0.9)

ggplot(foo2,aes(x=factor(trial),y=meanPupil,color=factor(condition),fill=factor(condition)))+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  geom_bar(stat="identity",position=dodge)+
  ggtitle("Looking at target (Liberal)")+
  labs(x = "Trial", y = "Pupil change from baseline")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  theme(plot.title = element_text(hjust = 0.5))+
  scale_y_continuous(labels=percent,limits=c(-0.3,.1),breaks=seq(-0.3,.1,.05))+
  scale_x_discrete(breaks=c("0","1"),labels=c("ISI", "Image"))+
  geom_errorbar(limits, width=0.25,position = position_dodge(0.9),color="black")+
  guides(color=FALSE)+
  theme(legend.position="bottom")+
  scale_fill_brewer(palette="Accent",name="Condition",breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  scale_color_brewer(palette="Accent")

```

Compare pupil size for condition (looking at target, conservative)
```{r}
# calculate mean pupil for each trial
foo <- group_by(poo, subID, TRIAL_INDEX_RECODE, trial, condition, lookattarget) %>%
  summarise(
    pupilsize=mean(PUPIL_CORRECTED, na.rm = TRUE)
  )

# collapse across subjects
foo2 <- group_by(foo, trial, condition,lookattarget) %>%
  summarise(
    meanPupil=mean(pupilsize,na.rm = TRUE),
    sePupil=sd(pupilsize, na.rm = TRUE)/sqrt(length(pupilsize))
  )

#only looking at target
foo2 <- subset(foo2, lookattarget==1)

# plot
limits <- aes(ymax = meanPupil + sePupil, ymin=meanPupil - sePupil)
dodge <- position_dodge(width=0.9)

ggplot(foo2,aes(x=factor(trial),y=meanPupil,color=factor(condition),fill=factor(condition)))+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  geom_bar(stat="identity",position=dodge)+
  ggtitle("Looking at target (Conservative)")+
  labs(x = "Trial", y = "Pupil change from baseline")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  theme(plot.title = element_text(hjust = 0.5))+
  scale_y_continuous(labels=percent,limits=c(-0.3,.1),breaks=seq(-0.3,.1,.05))+
  scale_x_discrete(breaks=c("0","1"),labels=c("ISI", "Image"))+
  geom_errorbar(limits, width=0.25,position = position_dodge(0.9),color="black")+
  guides(color=FALSE)+
  theme(legend.position="bottom")+
  scale_fill_brewer(palette="Accent",name="Condition",breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  scale_color_brewer(palette="Accent")

#unpredictable condition has smaller pupil response
```

AEM coding using liberal method 
```{r}
# get test phase data
aemwindow <- subset(orig.sample.a, phase==1)

# count number of consecutive looks
aemwindow$targetcount <- sequence(rle(aemwindow$lookattarget_lib)$lengths)

# calculate diff column so we know when a look starts and stops
aemwindow$diff <- c(diff(aemwindow$targetcount),-aemwindow$targetcount[length(aemwindow$RECORDING_SESSION_LABEL)])

# only care about eye movements initiated between 150ms - 1350ms bc of AEM
aemwindow$keep <- 1
rownum_lookstart <- which(aemwindow$targetcount==1) #where each look starts

for (i in 1:length(rownum_lookstart)){
  time <- aemwindow$TIMECODE_RECODE[rownum_lookstart[i]]  #time look starts
  if (time < 150 | time > 1350) { #remove it
    aemwindow$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
  }
}

# make sure look is longer than 100ms
rownum_lookstart <- which(aemwindow$targetcount==1) #where each look starts

for (i in 1:length(rownum_lookstart)){
  if (i==length(rownum_lookstart)) { #it's the last look
    lengthoflook <- aemwindow$diff[length(aemwindow$subID)] #the last row of the DF
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      aemwindow$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  } else {
    rownum_end <- rownum_lookstart[i+1] - 1 #row num when look ends
    lengthoflook <- aemwindow$diff[rownum_end] #length of look
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      aemwindow$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  }
}

# remove bad looks
poo <- subset(aemwindow, keep == 1)

# remove bad eye gazes
poo <- subset(poo, lookattarget_lib !=9)

# groups last sample of every AEM
aemcodingall <- subset(poo, diff !=1)

# separate it by correct, incorrect, together
aemcoding_lib_correct <- subset(aemcodingall, lookattarget_lib==1)
aemcoding_lib_incorrect <- subset(aemcodingall, lookattarget_lib==0)
aemcoding_lib <- subset(aemcodingall, lookattarget_lib !=5)
```

AEM coding using conservative method 
```{r}
# get test phase data
aemwindow <- subset(orig.sample.a, phase==1)

# count number of consecutive looks
aemwindow$targetcount <- sequence(rle(aemwindow$lookattarget)$lengths)

# calculate diff column so we know when a look starts and stops
aemwindow$diff <- c(diff(aemwindow$targetcount),-aemwindow$targetcount[length(aemwindow$RECORDING_SESSION_LABEL)])

# only care about eye movements initiated between 150ms - 1350ms bc of AEM
aemwindow$keep <- 1
rownum_lookstart <- which(aemwindow$targetcount==1) #where each look starts

for (i in 1:length(rownum_lookstart)){
  time <- aemwindow$TIMECODE_RECODE[rownum_lookstart[i]]  #time look starts
  if (time < 150 | time > 1350) { #remove it
    aemwindow$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
  }
}

# make sure look is longer than 100ms
rownum_lookstart <- which(aemwindow$targetcount==1) #where each look starts

for (i in 1:length(rownum_lookstart)){
  if (i==length(rownum_lookstart)) { #it's the last look
    lengthoflook <- aemwindow$diff[length(aemwindow$subID)] #the last row of the DF
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      aemwindow$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  } else {
    rownum_end <- rownum_lookstart[i+1] - 1 #row num when look ends
    lengthoflook <- aemwindow$diff[rownum_end] #length of look
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      aemwindow$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  }
}

# remove bad looks
poo <- subset(aemwindow, keep == 1)

# remove bad eye gazes
poo <- subset(poo, lookattarget !=9)

# groups last sample of every AEM
aemcodingall <- subset(poo, diff !=1)

# separate it by correct, incorrect, together
aemcoding_con_correct <- subset(aemcodingall, lookattarget==1)
aemcoding_con_incorrect <- subset(aemcodingall, lookattarget==0)
aemcoding_con <- subset(aemcodingall, lookattarget !=5)
```

Compare number of AEMs for condition
Conservative
```{r}
# number of AEM in every trial
foo <- group_by(aemcoding_con, subID, TRIAL_INDEX_RECODE, condition, lookattarget) %>%
  summarise(
    aemnum=length(diff)
  )

# total number of AEM for each subject
foo2 <- group_by(foo, subID, condition,lookattarget) %>%
  summarise(
    totalAEM=sum(aemnum,na.rm = TRUE)
  )

# calculate percent AEM (number of AEM type/ total number of AEM)
subs <- unique(foo2$subID)
foo2$percentAEM <- 0

for (j in 1:length(subs)) {
  foo2$percentAEM[foo2$subID==subs[j] & foo2$condition==0] <- foo2$totalAEM[foo2$subID==subs[j] & foo2$condition==0]/ sum(foo2$totalAEM[foo2$subID==subs[j] & foo2$condition==0])
  foo2$percentAEM[foo2$subID==subs[j] & foo2$condition==1] <- foo2$totalAEM[foo2$subID==subs[j] & foo2$condition==1]/ sum(foo2$totalAEM[foo2$subID==subs[j] & foo2$condition==1])
}

# get mean and SE
foo3 <- group_by(foo2, condition,lookattarget) %>%
  summarise(
    meanAEM=mean(percentAEM,na.rm = TRUE),
    seAEM=sd(percentAEM, na.rm = TRUE)/sqrt(length(percentAEM))
  )

# plot
limits <- aes(ymax = meanAEM + seAEM, ymin=meanAEM - seAEM)
dodge <- position_dodge(width=0.9)

ggplot(foo3,aes(x=factor(condition),y=meanAEM,color=factor(lookattarget),fill=factor(lookattarget)))+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  geom_bar(stat="identity",position=dodge)+
  ggtitle("Conservative")+
  labs(x = "Condition", y = "% AEM (/total number of AEMs)")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  theme(plot.title = element_text(hjust = 0.5))+
  scale_y_continuous(labels=percent,limits=c(0,1),breaks=seq(0,1,.2))+
  scale_x_discrete(breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  geom_errorbar(limits, width=0.25,position = position_dodge(0.9),color="black")+
  guides(color=FALSE)+
  theme(legend.position="bottom")+
  scale_color_brewer(palette="Set1")+
  scale_fill_brewer(palette="Set1",name="AEM type",breaks=c("0","1"),labels=c("Incorrect", "Correct"))

#There doesn't seem to be making difference between conditions. Looks like Ss make more incorrect AEMs but is that actually incorrect AEM or just sticky fixation?
```

Compare number of AEMs for condition
Liberal
```{r}
# number of AEM in every trial
foo <- group_by(aemcoding_lib, subID, TRIAL_INDEX_RECODE, condition, lookattarget_lib) %>%
  summarise(
    aemnum=length(diff)
  )

# total number of AEM for each subject
foo2 <- group_by(foo, subID, condition,lookattarget_lib) %>%
  summarise(
    totalAEM=sum(aemnum,na.rm = TRUE)
  )

# calculate percent AEM (number of AEM type/ total number of AEM)
subs <- unique(foo2$subID)
foo2$percentAEM <- 0
for (j in 1:length(subs)) {
  foo2$percentAEM[foo2$subID==subs[j] & foo2$condition==0] <- foo2$totalAEM[foo2$subID==subs[j] & foo2$condition==0]/ sum(foo2$totalAEM[foo2$subID==subs[j] & foo2$condition==0])
  foo2$percentAEM[foo2$subID==subs[j] & foo2$condition==1] <- foo2$totalAEM[foo2$subID==subs[j] & foo2$condition==1]/ sum(foo2$totalAEM[foo2$subID==subs[j] & foo2$condition==1])
}

# get se and mean
foo3 <- group_by(foo2, condition,lookattarget_lib) %>%
  summarise(
    meanAEM=mean(percentAEM,na.rm = TRUE),
    seAEM=sd(percentAEM, na.rm = TRUE)/sqrt(length(percentAEM))
  )

# plot
limits <- aes(ymax = meanAEM + seAEM, ymin=meanAEM - seAEM)
dodge <- position_dodge(width=0.9)

ggplot(foo3,aes(x=factor(condition),y=meanAEM,color=factor(lookattarget_lib),fill=factor(lookattarget_lib)))+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  geom_bar(stat="identity",position=dodge)+
  ggtitle("Liberal")+
  labs(x = "Condition", y = "% AEM (/total number of AEMs)")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  theme(plot.title = element_text(hjust = 0.5))+
  scale_y_continuous(labels=percent,limits=c(0,1),breaks=seq(0,1,.2))+
  scale_x_discrete(breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  geom_errorbar(limits, width=0.25,position = position_dodge(0.9),color="black")+
  guides(color=FALSE)+
  theme(legend.position="bottom")+
  scale_color_brewer(palette="Set1")+
  scale_fill_brewer(palette="Set1",name="AEM type",breaks=c("0","1"),labels=c("Incorrect", "Correct"))

#There seems to be a much larger gap between correct and incorrect AEM for unpredictable condition, but not predictable.
```

Speed of REM different between conditions?
Liberal 
```{r}
#1. CALCULATE BASELINE (using training phase) RT for REM 

# get training phase data
speedbaseline <- subset(orig.sample.a, phase==0)

# count number of consecutive looks
speedbaseline$targetcount <- sequence(rle(speedbaseline$lookattarget_lib)$lengths)

# calculate diff column so we know when a look starts and stops
speedbaseline$diff <- c(diff(speedbaseline$targetcount),-speedbaseline$targetcount[length(speedbaseline$RECORDING_SESSION_LABEL)])

# make sure look is over 100ms
speedbaseline$keep <- 1
rownum_lookstart <- which(speedbaseline$targetcount==1) #where each look starts
for (i in 1:length(rownum_lookstart)){
  if (i==length(rownum_lookstart)) { #it's the last look
    lengthoflook <- speedbaseline$diff[length(speedbaseline$subID)] #the last row of the DF
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  } else {
    rownum_end <- rownum_lookstart[i+1] - 1 #row num when look ends
    lengthoflook <- speedbaseline$diff[rownum_end] #length of look
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  }
}

# remove short looks
speedbaseline <- subset(speedbaseline, keep == 1)

# make sure it's look to target 
speedbaseline <- subset(speedbaseline, lookattarget_lib == 1)

# only care about first look
firstlook <- subset(speedbaseline, targetcount==1)

# classify look as REM (after 1350ms) or not 
firstlook$aemrem <- 0
firstlook$aemrem[firstlook$TIMECODE_RECODE > 1350] <- 1

# only care about REM
firstlook <- subset(firstlook, aemrem == 1)

# remove duplicate (i.e. make more than 1 REM)
firstlook <- firstlook %>% 
        group_by(subID,condition,TRIAL_INDEX_RECODE) %>%
        top_n(1, -TIMECODE_RECODE) #- for min value instead of stop value

# average baseline RT for REM
aemrembaseline <- group_by(firstlook, subID, aemrem) %>%
  summarise(
    baselinert = max(TIMECODE_RECODE, na.rm = TRUE)
  )

#TEST PHASE
speedbaseline <- subset(orig.sample.a, phase==1)

# count number of consecutive looks
speedbaseline$targetcount <- sequence(rle(speedbaseline$lookattarget_lib)$lengths)

# calculate diff column so we know when a look starts and stops
speedbaseline$diff <- c(diff(speedbaseline$targetcount),-speedbaseline$targetcount[length(speedbaseline$RECORDING_SESSION_LABEL)])

# make sure look is over 100ms
speedbaseline$keep <- 1
rownum_lookstart <- which(speedbaseline$targetcount==1) #where each look starts
for (i in 1:length(rownum_lookstart)){
  if (i==length(rownum_lookstart)) { #it's the last look
    lengthoflook <- speedbaseline$diff[length(speedbaseline$subID)] #the last row of the DF
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  } else {
    rownum_end <- rownum_lookstart[i+1] - 1 #row num when look ends
    lengthoflook <- speedbaseline$diff[rownum_end] #length of look
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  }
}

# remove short looks
speedbaseline <- subset(speedbaseline, keep == 1)

# make sure it's look to target 
speedbaseline <- subset(speedbaseline, lookattarget_lib == 1)

# only care about first look
firstlook <- subset(speedbaseline, targetcount==1)

# classify look as REM (after 1350ms) or not 
firstlook$aemrem <- 0
firstlook$aemrem[firstlook$TIMECODE_RECODE > 1350] <- 1

# only care about REM
firstlook <- subset(firstlook, aemrem == 1)

# remove duplicate (i.e. make more than 1 REM)
firstlook <- firstlook %>% 
        group_by(subID,condition,TRIAL_INDEX_RECODE) %>%
        top_n(1, -TIMECODE_RECODE) #- for min value instead of stop value

# average baseline RT for REM
rem_testphase <- group_by(firstlook, subID, aemrem, condition) %>%
  summarise(
    testrt = max(TIMECODE_RECODE, na.rm = TRUE)
  )

#combine DF
rem_testphase <- merge(rem_testphase, aemrembaseline)

rem_testphase$timediff <- rem_testphase$baselinert - rem_testphase$testrt 
#positive number = test phase is slower, negative number = test phase is faster

foo <- group_by(rem_testphase, condition) %>%
  summarise(
    meanRT = mean(timediff, na.rm = TRUE),
    seRT=sd(timediff, na.rm = TRUE)/sqrt(length(timediff))
  )

#plot
dodge <- position_dodge(width=0.9)
limits <- aes(ymax = meanRT + seRT, ymin=meanRT - seRT)

ggplot(foo,aes(x=factor(condition),y=meanRT,color=factor(condition),fill=factor(condition)))+
  geom_bar(stat="identity",position=dodge)+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  labs(x = "Condition", y = "REM: Test RT - Training RT (ms)")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=16),axis.text.y  = element_text(size=16))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  scale_y_continuous(limits=c(-20,170),breaks=seq(-20,170,20))+
  scale_x_discrete(breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  geom_errorbar(limits, width=0.25,position = position_dodge(0.9),color="black")+
  guides(color=FALSE, fill=FALSE)+
  geom_hline(yintercept = 0, color="black",size=1)+
  scale_color_brewer(palette="Accent")+
  scale_fill_brewer(palette="Accent")

```

Speed of REM different between conditions?
Conservative 
```{r}
#1. CALCULATE BASELINE (using training phase) RT for REM 

# get training phase data
speedbaseline <- subset(orig.sample.a, phase==0)

# count number of consecutive looks
speedbaseline$targetcount <- sequence(rle(speedbaseline$lookattarget)$lengths)

# calculate diff column so we know when a look starts and stops
speedbaseline$diff <- c(diff(speedbaseline$targetcount),-speedbaseline$targetcount[length(speedbaseline$RECORDING_SESSION_LABEL)])

# make sure look is over 100ms
speedbaseline$keep <- 1
rownum_lookstart <- which(speedbaseline$targetcount==1) #where each look starts
for (i in 1:length(rownum_lookstart)){
  if (i==length(rownum_lookstart)) { #it's the last look
    lengthoflook <- speedbaseline$diff[length(speedbaseline$subID)] #the last row of the DF
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  } else {
    rownum_end <- rownum_lookstart[i+1] - 1 #row num when look ends
    lengthoflook <- speedbaseline$diff[rownum_end] #length of look
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  }
}

# remove short looks
speedbaseline <- subset(speedbaseline, keep == 1)

# make sure it's look to target 
speedbaseline <- subset(speedbaseline, lookattarget == 1)

# only care about first look
firstlook <- subset(speedbaseline, targetcount==1)

# classify look as REM (after 1350ms) or not 
firstlook$aemrem <- 0
firstlook$aemrem[firstlook$TIMECODE_RECODE > 1350] <- 1

# only care about REM
firstlook <- subset(firstlook, aemrem == 1)

# remove duplicate (i.e. make more than 1 REM)
firstlook <- firstlook %>% 
        group_by(subID,condition,TRIAL_INDEX_RECODE) %>%
        top_n(1, -TIMECODE_RECODE) #- for min value instead of stop value

# average baseline RT for REM
aemrembaseline <- group_by(firstlook, subID, aemrem) %>%
  summarise(
    baselinert = max(TIMECODE_RECODE, na.rm = TRUE)
  )

#TEST PHASE
speedbaseline <- subset(orig.sample.a, phase==1)

# count number of consecutive looks
speedbaseline$targetcount <- sequence(rle(speedbaseline$lookattarget)$lengths)

# calculate diff column so we know when a look starts and stops
speedbaseline$diff <- c(diff(speedbaseline$targetcount),-speedbaseline$targetcount[length(speedbaseline$RECORDING_SESSION_LABEL)])

# make sure look is over 100ms
speedbaseline$keep <- 1
rownum_lookstart <- which(speedbaseline$targetcount==1) #where each look starts
for (i in 1:length(rownum_lookstart)){
  if (i==length(rownum_lookstart)) { #it's the last look
    lengthoflook <- speedbaseline$diff[length(speedbaseline$subID)] #the last row of the DF
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  } else {
    rownum_end <- rownum_lookstart[i+1] - 1 #row num when look ends
    lengthoflook <- speedbaseline$diff[rownum_end] #length of look
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  }
}

# remove short looks
speedbaseline <- subset(speedbaseline, keep == 1)

# make sure it's look to target 
speedbaseline <- subset(speedbaseline, lookattarget == 1)

# only care about first look
firstlook <- subset(speedbaseline, targetcount==1)

# classify look as REM (after 1350ms) or not 
firstlook$aemrem <- 0
firstlook$aemrem[firstlook$TIMECODE_RECODE > 1350] <- 1

# only care about REM
firstlook <- subset(firstlook, aemrem == 1)

# remove duplicate (i.e. make more than 1 REM)
firstlook <- firstlook %>% 
        group_by(subID,condition,TRIAL_INDEX_RECODE) %>%
        top_n(1, -TIMECODE_RECODE) #- for min value instead of stop value

# average baseline RT for REM
rem_testphase <- group_by(firstlook, subID, aemrem, condition) %>%
  summarise(
    testrt = max(TIMECODE_RECODE, na.rm = TRUE)
  )

#combine DF
rem_testphase <- merge(rem_testphase, aemrembaseline)

rem_testphase$timediff <- rem_testphase$baselinert - rem_testphase$testrt 
#positive number = test phase is slower, negative number = test phase is faster

foo <- group_by(rem_testphase, condition) %>%
  summarise(
    meanRT = mean(timediff, na.rm = TRUE),
    seRT=sd(timediff, na.rm = TRUE)/sqrt(length(timediff))
  )

#plot
dodge <- position_dodge(width=0.9)
limits <- aes(ymax = meanRT + seRT, ymin=meanRT - seRT)

ggplot(foo,aes(x=factor(condition),y=meanRT,color=factor(condition),fill=factor(condition)))+
  geom_bar(stat="identity",position=dodge)+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  labs(x = "Condition", y = "REM: Test RT - Training RT (ms)")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=16),axis.text.y  = element_text(size=16))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  scale_y_continuous(limits=c(-20,170),breaks=seq(-20,170,20))+
  scale_x_discrete(breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  geom_errorbar(limits, width=0.25,position = position_dodge(0.9),color="black")+
  guides(color=FALSE, fill=FALSE)+
  geom_hline(yintercept = 0, color="black",size=1)+
  scale_color_brewer(palette="Accent")+
  scale_fill_brewer(palette="Accent")

```

REM trial by trial
Liberal
```{r}
# get test phase data
speedbaseline <- subset(orig.sample.a, phase==1)

# count number of consecutive looks
speedbaseline$targetcount <- sequence(rle(speedbaseline$lookattarget_lib)$lengths)

# calculate diff column so we know when a look starts and stops
speedbaseline$diff <- c(diff(speedbaseline$targetcount),-speedbaseline$targetcount[length(speedbaseline$RECORDING_SESSION_LABEL)])

# make sure look is over 100ms
speedbaseline$keep <- 1
rownum_lookstart <- which(speedbaseline$targetcount==1) #where each look starts
for (i in 1:length(rownum_lookstart)){
  if (i==length(rownum_lookstart)) { #it's the last look
    lengthoflook <- speedbaseline$diff[length(speedbaseline$subID)] #the last row of the DF
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  } else {
    rownum_end <- rownum_lookstart[i+1] - 1 #row num when look ends
    lengthoflook <- speedbaseline$diff[rownum_end] #length of look
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  }
}

# remove short looks
speedbaseline <- subset(speedbaseline, keep == 1)

# make sure it's look to target 
speedbaseline <- subset(speedbaseline, lookattarget_lib == 1)

# only care about first look
firstlook <- subset(speedbaseline, targetcount==1)

# classify look as REM (after 1350ms) or not 
firstlook$aemrem <- 0
firstlook$aemrem[firstlook$TIMECODE_RECODE > 1350] <- 1

# only care about REM
firstlook <- subset(firstlook, aemrem == 1)

# remove duplicate (i.e. make more than 1 REM)
firstlook <- firstlook %>% 
        group_by(subID,condition,TRIAL_INDEX_RECODE) %>%
        top_n(1, -TIMECODE_RECODE) #- for min value instead of stop value

#create DF
remtrialbytrial <- group_by(firstlook, subID, condition, TRIAL_INDEX_RECODE) %>%
  summarise(
    rt = mean(TIMECODE_RECODE, na.rm = TRUE)
  )

remtrialbytrial$rt <- remtrialbytrial$rt - 1200 #subtract 1200ms because duration of ISI

remtrialbytrial$timesseen <- 0
for (j in 1:length(subs)) {
  x <- length(remtrialbytrial$TRIAL_INDEX_RECODE[remtrialbytrial$subID==subs[j] & remtrialbytrial$condition==0])
  xx <- length(remtrialbytrial$TRIAL_INDEX_RECODE[remtrialbytrial$subID==subs[j] & remtrialbytrial$condition==1])
  remtrialbytrial$timesseen[remtrialbytrial$subID==subs[j] & remtrialbytrial$condition==0] <- 1:x
  remtrialbytrial$timesseen[remtrialbytrial$subID==subs[j] & remtrialbytrial$condition==1] <- 1:xx
}

foo <- group_by(remtrialbytrial, condition, timesseen) %>%
  summarise(
    meanRT = mean(rt, na.rm = TRUE),
    seRT=sd(rt, na.rm = TRUE)/sqrt(length(rt))
  )

ggplot(foo,aes(x=timesseen,y=meanRT,color=factor(condition),fill=factor(condition)))+
  geom_line(size=1)+geom_point(size=3)+
  ggtitle("Changes in REM RT (Liberal)")+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  labs(x = "REM number", y = "Time (ms)")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  scale_y_continuous(limits=c(0,1000),breaks=seq(0,1000,100))+
  scale_x_continuous(limits=c(1,30),breaks=seq(1,30,2))+
  scale_color_brewer(palette="Accent",name="Condition",breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  scale_fill_brewer(palette="Accent")+
  theme(legend.position="bottom")+
  theme(plot.title = element_text(hjust = 0.5))+
  guides(fill=FALSE)
```

REM trial by trial
Conservative
```{r}
# get test phase data
speedbaseline <- subset(orig.sample.a, phase==1)

# count number of consecutive looks
speedbaseline$targetcount <- sequence(rle(speedbaseline$lookattarget)$lengths)

# calculate diff column so we know when a look starts and stops
speedbaseline$diff <- c(diff(speedbaseline$targetcount),-speedbaseline$targetcount[length(speedbaseline$RECORDING_SESSION_LABEL)])

# make sure look is over 100ms
speedbaseline$keep <- 1
rownum_lookstart <- which(speedbaseline$targetcount==1) #where each look starts
for (i in 1:length(rownum_lookstart)){
  if (i==length(rownum_lookstart)) { #it's the last look
    lengthoflook <- speedbaseline$diff[length(speedbaseline$subID)] #the last row of the DF
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  } else {
    rownum_end <- rownum_lookstart[i+1] - 1 #row num when look ends
    lengthoflook <- speedbaseline$diff[rownum_end] #length of look
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  }
}

# remove short looks
speedbaseline <- subset(speedbaseline, keep == 1)

# make sure it's look to target 
speedbaseline <- subset(speedbaseline, lookattarget == 1)

# only care about first look
firstlook <- subset(speedbaseline, targetcount==1)

# classify look as REM (after 1350ms) or not 
firstlook$aemrem <- 0
firstlook$aemrem[firstlook$TIMECODE_RECODE > 1350] <- 1

# only care about REM
firstlook <- subset(firstlook, aemrem == 1)

# remove duplicate (i.e. make more than 1 REM)
firstlook <- firstlook %>% 
        group_by(subID,condition,TRIAL_INDEX_RECODE) %>%
        top_n(1, -TIMECODE_RECODE) #- for min value instead of stop value

#create DF
remtrialbytrial <- group_by(firstlook, subID, condition, TRIAL_INDEX_RECODE) %>%
  summarise(
    rt = mean(TIMECODE_RECODE, na.rm = TRUE)
  )

remtrialbytrial$rt <- remtrialbytrial$rt - 1200 #subtract 1200ms because duration of ISI

remtrialbytrial$timesseen <- 0
for (j in 1:length(subs)) {
  x <- length(remtrialbytrial$TRIAL_INDEX_RECODE[remtrialbytrial$subID==subs[j] & remtrialbytrial$condition==0])
  xx <- length(remtrialbytrial$TRIAL_INDEX_RECODE[remtrialbytrial$subID==subs[j] & remtrialbytrial$condition==1])
  remtrialbytrial$timesseen[remtrialbytrial$subID==subs[j] & remtrialbytrial$condition==0] <- 1:x
  remtrialbytrial$timesseen[remtrialbytrial$subID==subs[j] & remtrialbytrial$condition==1] <- 1:xx
}

foo <- group_by(remtrialbytrial, condition, timesseen) %>%
  summarise(
    meanRT = mean(rt, na.rm = TRUE),
    seRT=sd(rt, na.rm = TRUE)/sqrt(length(rt))
  )

ggplot(foo,aes(x=timesseen,y=meanRT,color=factor(condition),fill=factor(condition)))+
  geom_line(size=1)+geom_point(size=3)+
  ggtitle("Changes in REM RT (Conservative)")+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  labs(x = "REM number", y = "Time (ms)")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  scale_y_continuous(limits=c(0,1000),breaks=seq(0,1000,100))+
  scale_x_continuous(limits=c(1,30),breaks=seq(1,30,2))+
  scale_color_brewer(palette="Accent",name="Condition",breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  scale_fill_brewer(palette="Accent")+
  theme(legend.position="bottom")+
  theme(plot.title = element_text(hjust = 0.5))+
  guides(fill=FALSE)
```

AEM trial by trial
liberal
```{r}
# get test phase data
speedbaseline <- subset(orig.sample.a, phase==1)

# count number of consecutive looks
speedbaseline$targetcount <- sequence(rle(speedbaseline$lookattarget_lib)$lengths)

# calculate diff column so we know when a look starts and stops
speedbaseline$diff <- c(diff(speedbaseline$targetcount),-speedbaseline$targetcount[length(speedbaseline$RECORDING_SESSION_LABEL)])

# only care about eye movements initiated between 150ms - 1350ms bc of AEM
speedbaseline$keep <- 1
rownum_lookstart <- which(speedbaseline$targetcount==1) #where each look starts

for (i in 1:length(rownum_lookstart)){
  time <- speedbaseline$TIMECODE_RECODE[rownum_lookstart[i]]  #time look starts
  if (time < 150 | time > 1350) { #remove it
    speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
  }
}

# make sure look is longer than 100ms
rownum_lookstart <- which(speedbaseline$targetcount==1) #where each look starts

for (i in 1:length(rownum_lookstart)){
  if (i==length(rownum_lookstart)) { #it's the last look
    lengthoflook <- speedbaseline$diff[length(speedbaseline$subID)] #the last row of the DF
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  } else {
    rownum_end <- rownum_lookstart[i+1] - 1 #row num when look ends
    lengthoflook <- speedbaseline$diff[rownum_end] #length of look
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  }
}

# remove non AEM looks and short looks
poo <- subset(speedbaseline, keep == 1)

# remove bad eye gazes
poo <- subset(poo, lookattarget_lib !=9)

# only care about first look
firstlook <- subset(poo, targetcount==1)

# remove duplicate (i.e. make more than 1 REM)
firstlook <- firstlook %>% 
        group_by(subID,condition,TRIAL_INDEX_RECODE) %>%
        top_n(1, -TIMECODE_RECODE) #- for min value instead of stop value

#create DF
aemtrialbytrial <- group_by(firstlook, subID, condition, TRIAL_INDEX_RECODE) %>%
  summarise(
    rt = mean(TIMECODE_RECODE, na.rm = TRUE)
  )

# add in times seen
aemtrialbytrial$timesseen <- 0
for (j in 1:length(subs)) {
  x <- length(aemtrialbytrial$TRIAL_INDEX_RECODE[aemtrialbytrial$subID==subs[j] & aemtrialbytrial$condition==0])
  xx <- length(aemtrialbytrial$TRIAL_INDEX_RECODE[aemtrialbytrial$subID==subs[j] & aemtrialbytrial$condition==1])
  aemtrialbytrial$timesseen[aemtrialbytrial$subID==subs[j] & aemtrialbytrial$condition==0] <- 1:x
  aemtrialbytrial$timesseen[aemtrialbytrial$subID==subs[j] & aemtrialbytrial$condition==1] <- 1:xx
}

# get mean and SE
foo <- group_by(aemtrialbytrial, condition, timesseen) %>%
  summarise(
    meanRT = mean(rt, na.rm = TRUE),
    seRT=sd(rt, na.rm = TRUE)/sqrt(length(rt))
  )

# plot
ggplot(foo,aes(x=timesseen,y=meanRT,color=factor(condition),fill=factor(condition)))+
  geom_line(size=1)+geom_point(size=3)+
  ggtitle("Changes in AEM RT (Liberal)")+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  labs(x = "AEM number", y = "Time (ms)")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  scale_y_continuous(limits=c(150,1350),breaks=seq(150,1350,100))+
  scale_x_continuous(limits=c(1,30),breaks=seq(1,30,2))+
  scale_color_brewer(palette="Accent",name="Condition",breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  scale_fill_brewer(palette="Accent")+
  theme(legend.position="bottom")+
  theme(plot.title = element_text(hjust = 0.5))+
  guides(fill=FALSE)
```

AEM trial by trial
conservative
```{r}
# get test phase data
speedbaseline <- subset(orig.sample.a, phase==1)

# count number of consecutive looks
speedbaseline$targetcount <- sequence(rle(speedbaseline$lookattarget)$lengths)

# calculate diff column so we know when a look starts and stops
speedbaseline$diff <- c(diff(speedbaseline$targetcount),-speedbaseline$targetcount[length(speedbaseline$RECORDING_SESSION_LABEL)])

# only care about eye movements initiated between 150ms - 1350ms bc of AEM
speedbaseline$keep <- 1
rownum_lookstart <- which(speedbaseline$targetcount==1) #where each look starts

for (i in 1:length(rownum_lookstart)){
  time <- speedbaseline$TIMECODE_RECODE[rownum_lookstart[i]]  #time look starts
  if (time < 150 | time > 1350) { #remove it
    speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
  }
}

# make sure look is longer than 100ms
rownum_lookstart <- which(speedbaseline$targetcount==1) #where each look starts

for (i in 1:length(rownum_lookstart)){
  if (i==length(rownum_lookstart)) { #it's the last look
    lengthoflook <- speedbaseline$diff[length(speedbaseline$subID)] #the last row of the DF
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  } else {
    rownum_end <- rownum_lookstart[i+1] - 1 #row num when look ends
    lengthoflook <- speedbaseline$diff[rownum_end] #length of look
    if (lengthoflook > -25) { #shorter than 100ms, remove it
      speedbaseline$keep[(rownum_lookstart[i]):(rownum_lookstart[i+1] - 1)] <- 0
    }
  }
}

# remove non AEM looks and short looks
poo <- subset(speedbaseline, keep == 1)

# remove bad eye gazes
poo <- subset(poo, lookattarget !=9)

# only care about first look
firstlook <- subset(poo, targetcount==1)

# remove duplicate (i.e. make more than 1 REM)
firstlook <- firstlook %>% 
        group_by(subID,condition,TRIAL_INDEX_RECODE) %>%
        top_n(1, -TIMECODE_RECODE) #- for min value instead of stop value

#create DF
aemtrialbytrial <- group_by(firstlook, subID, condition, TRIAL_INDEX_RECODE) %>%
  summarise(
    rt = mean(TIMECODE_RECODE, na.rm = TRUE)
  )

# add in times seen
aemtrialbytrial$timesseen <- 0
for (j in 1:length(subs)) {
  x <- length(aemtrialbytrial$TRIAL_INDEX_RECODE[aemtrialbytrial$subID==subs[j] & aemtrialbytrial$condition==0])
  xx <- length(aemtrialbytrial$TRIAL_INDEX_RECODE[aemtrialbytrial$subID==subs[j] & aemtrialbytrial$condition==1])
  aemtrialbytrial$timesseen[aemtrialbytrial$subID==subs[j] & aemtrialbytrial$condition==0] <- 1:x
  aemtrialbytrial$timesseen[aemtrialbytrial$subID==subs[j] & aemtrialbytrial$condition==1] <- 1:xx
}

# get mean and SE
foo <- group_by(aemtrialbytrial, condition, timesseen) %>%
  summarise(
    meanRT = mean(rt, na.rm = TRUE),
    seRT=sd(rt, na.rm = TRUE)/sqrt(length(rt))
  )

# plot
ggplot(foo,aes(x=timesseen,y=meanRT,color=factor(condition),fill=factor(condition)))+
  geom_line(size=1)+geom_point(size=3)+
  ggtitle("Changes in AEM RT (Conservative)")+
  theme_bw()+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),axis.line = element_line(colour = "black"))+
  labs(x = "AEM number", y = "Time (ms)")+
  theme(plot.title = element_text(face="bold", size=20, hjust=0))+
  theme(axis.title = element_text(face="bold", size=20))+ 
  theme(axis.text.x  = element_text(size=20),axis.text.y  = element_text(size=20))+
  theme(legend.text=element_text(size=16),legend.title=element_text(size=16))+
  scale_y_continuous(limits=c(150,1350),breaks=seq(150,1350,100))+
  scale_x_continuous(limits=c(1,30),breaks=seq(1,30,2))+
  scale_color_brewer(palette="Accent",name="Condition",breaks=c("0","1"),labels=c("Unpredictable", "Predictable"))+
  scale_fill_brewer(palette="Accent")+
  theme(legend.position="bottom")+
  theme(plot.title = element_text(hjust = 0.5))+
  guides(fill=FALSE)
```
